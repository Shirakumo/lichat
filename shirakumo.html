<article><style>article{
    max-width: 1000px;
    font-size: 14pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="shirakumo extensions">Shirakumo Extensions</h1><p>This document outlines extensions to the Lichat core protocol. As with the core protocol, you can find a machine-readable version in <a class="external-link" href="shirakumo.sexpr">shirakumo.sexpr</a></p><h2 id="1. backfill (shirakumo-backfill)">1. Backfill (shirakumo-backfill)</h2><p>Purpose: allow users to catch up with the contents of a channel should they initiate a new connection which does not currently have access to all the past updates of the channel. </p><p>In order to facilitate this, the server is forced to keep copies of the updates. The server is allowed to only keep updates for a certain duration, or only a certain number of total updates. In order to avoid spying, the server should not distribute updates that the user did not already receive previously through another connection. The server does not have to make any guarantee about the order in which the updates are sent back to the connection. The client on the other side is responsible for ordering them as appropriate according to the clock.</p><p>A new update type called <code>backfill</code> is introduced, which is a <code>channel-update</code> and has an extra, optional field called <code>since</code> which should be a universal-time timestamp. If the server receives such an update from a connection, it reacts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>Following this, updates are sent back to the connection the update came from. These updates should include all updates that were distributed to users in the channel, spanning from now to an arbitrary point in time that is at most when the user of this connection last joined the channel and at most the specified <code>since</code> timestamp. The fields of the updates must be the equal to the first time the update was sent out. The initial event of the user that requested the backfill joining the channel cannot be sent back.</p></li><li value="3"><p>The original update is sent back to the user to indicate end of backfill.</p></li></ol><h2 id="2. data (shirakumo-data)">2. Data (shirakumo-data)</h2><p>Purpose: allows distributing images and other binary payloads.</p><p>A new update type called <code>data</code> is introduced, which is a <code>channel-update</code>. Additionally, a new <code>failure</code> type called <code>bad-content-type</code> is introduced, which is an <code>update-failure</code>. If the server receives a <code>data</code> update from a connection, it reacts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the update's <code>content-type</code> is not accepted by the server, a <code>bad-content-type</code> update is sent back and the request is dropped.</p></li><li value="3"><p>The user's <code>data</code> update is distributed to all users in the channel.</p></li></ol><p>The <code>data</code> update contains three slots, with the following intentions:</p><ul><li><p><code>content-type</code> A string representing the <a class="external-link" href="https://en.wikipedia.org/wiki/Media_type">content type</a> of the payload data contained in the update.</p></li><li><p><code>filename</code> A string representing an arbitrary name given to the payload data.</p></li><li><p><code>payload</code> A base-64 encoded string of binary data payload.</p></li></ul><h2 id="3. emotes (shirakumo-emotes)">3. Emotes (shirakumo-emotes)</h2><p>Purpose: introduces server-side emoticons that are distributed to all users for use on the client-side.</p><p>Any non-anonymous channel created by a registered user holds an <code>emotes</code> map. The server may restrict the size of this map. The server should also set the default permissions for <code>emotes</code> to anyone, and <code>emote</code> to only the registrant.</p><p>Two new update types called <code>emotes</code> and <code>emote</code> are introduced, both of which are <code>channel-update</code>s.</p><p>The <code>emotes</code> update contains one extra slot, with the following intentions:</p><ul><li><p><code>names</code> This contains a list of strings denoting the names of emotes the client knows about.</p></li></ul><p>The <code>emote</code> update contains three extra slots, with the following intentions:</p><ul><li><p><code>content-type</code> A string representing the <a class="external-link" href="https://en.wikipedia.org/wiki/Media_type">content type</a> of the emote image contained in the update.</p></li><li><p><code>name</code> A string representing the name of the emote.</p></li><li><p><code>payload</code> A base-64 encoded string of binary data payload.</p></li></ul><p>If the server receives an <code>emotes</code> update from a connection, it reacts as follows:</p><ol><li value="1"><p>If the channel field is missing, the primary channel's name is substituted.</p></li><li value="2"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="3"><p>If the channel is anonymous or wasn't created by a registered user, an <code>insufficient-permissions</code> update is sent back and the request is dropped.</p></li><li value="4"><p>The server computes a set difference between the known emote names for the channel, and the names listed in the event's <code>names</code> slot. Emote names are case-insensitive.</p></li><li value="5"><p>For each emote in the calculated set, the server sends back an <code>emote</code> update, where the <code>name</code> is set to the emote's name, the <code>channel</code> to the channel, and the <code>payload</code> is set to the base-64 encoded image representing the emote. The <code>content-type</code> must be set accordingly.</p></li><li value="6"><p>The server sends back the original <code>emotes</code> update, having set the <code>names</code> field to the list of known emotes for this channel.</p></li></ol><p>If the server receives an <code>emote</code> update from a connection, it reacts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the <code>name</code> is not yet contained in the channel's <code>emotes</code> map, and the map already matches the size restriction of the server, an <code>emote-list-full</code> update is sent back and the request is dropped.</p></li><li value="3"><p>If the <code>content-type</code> is not acceptable, an update of type <code>bad-content-type</code> is sent back and the request is dropped.</p></li><li value="4"><p>If the payload exceeds internal limits, an update of type <code>update-too-long</code> is sent back and the request is dropped.</p></li><li value="5"><p>If the payload is empty, the emote is removed, and otherwise the emote data is stored in the channel's <code>emotes</code> map.</p></li><li value="6"><p>The <code>emote</code> update is distributed to all users in the channel.</p></li></ol><p>When the client receives an <code>emote</code> update from the server, it reacts as follows:</p><ol><li value="1"><p>The <code>payload</code> and <code>content-type</code> are associated with the <code>name</code> and <code>channel</code>, and are persisted on the client. When the client sends an <code>emotes</code> event for the channel to the server it should include the name of this emote in the <code>names</code> list.</p></li></ol><p>When the client sees a <code>message</code> update, every match of the regex <code>:([^:]+):</code> in the <code>text</code> where the group matched by the regex is the name of an emote from the known list of emotes for the current channel or the primary channel, then the match of the regex should be displayed to the user by an image of the emote's image.</p><h2 id="4. edit (shirakumo-edit)">4. Edit (shirakumo-edit)</h2><p>Purpose: allows users to make retroactive edits to their messages.</p><p>A new update type called <code>edit</code> is introduced, which is a <code>message</code>. If the server receives an <code>edit</code> update it acts in the same way as a regular <code>message</code> event. No additional support from the server is required outside of recognising and accepting the type.</p><p>When the client sees an <code>edit</code> update, it should change the <code>text</code> of the <code>message</code> update with the same <code>from</code> and <code>id</code> fields to the one from the <code>edit</code> update. Ideally a user interface for Lichat should also include an indication that the previous message event has been changed, including perhaps even a history of all the potential edits of a message. If the <code>text</code> field of the <code>edit</code> update is empty, the message should be marked as deleted, or removed outright.</p><p>If the client receives an <code>edit</code> update whose <code>id</code> and <code>from</code> fields do not refer to any previous <code>message</code> update, the client should simply ignore the update. The client <em>may</em> make an exception for other content updates like <code>data</code> or <code>link</code> when the <code>text</code> of the <code>edit</code> is empty, causing the update to be marked as deleted.</p><p>If the client also supports the <code>shirakumo-markup</code> extension, it should also update the <code>rich</code> field of the original <code>message</code>.</p><h2 id="5. channel trees (shirakumo-channel-trees)">5. Channel Trees (shirakumo-channel-trees)</h2><p>Purpose: enforces a structure on channels and allows creating channel hierarchies for easier grouping.</p><p>A new convention for channel names is introduced. §2.4.4 is restricted further in the following manner: forward slash characters (<code>U+002F</code>) may only occur between two other characters that are not a forward slash character.</p><p>Generally for a <code>channel-update</code>, the following terminology is introduced: the <code>parent channel</code> is a channel with the name of the current channel up to and excluding the last forward slash character in the name. If no forward slash occurs in the name, the primary channel is considered the parent channel.</p><p>A new error <code>no-such-parent-channel</code> is introduced. It is an <code>update-failure</code>.</p><p>§5.3.1 is modified as follows: instead of point <code>1</code>: If the parent channel does not exist, the server responds with a <code>no-such-parent-channel</code> update and drops the request. If the parent channel exists, the update is checked for permissions by the parent channel.</p><p>§5.5.1 is modified as follows: the <code>channels</code> update is upgraded to a <code>channel-update</code> and as such contains a <code>channel</code> field. When processing the <code>channels</code> update, the server should only process channels whose names begin with the name mentioned in the <code>channel</code> field followed by a forward slash and do not contain any further forward slashes.</p><p>Specifically, an update requesting <code>foo</code> should list <code>foo/bar</code>, but not <code>foo/bar/baz</code>.</p><p>Clients that support this extension are required to implement the following special semantic: if a user uses a command that requires a channel name, and the user begins the channel name with a forward slash, the client should automatically prepend the current channel name to the specified channel name, if there is a channel that is considered &quot;current&quot;. If no channel is explicitly current, the primary channel is considered current.</p><p>If the client also supports the <code>shirakumo-emotes</code> extension, it should make sure that emotes from ancestor channels are available in any descendant channel.</p><h2 id="6. channel info (shirakumo-channel-info)">6. Channel Info (shirakumo-channel-info)</h2><p>Purpose: allows associating metadata with channels such as the set of rules, a topic, and so forth.</p><p>Channels receive extra metadata fields that can be set set by users. To this end, channels must keep a table of <code>metadata</code> to track. The server must restrict the valid keys in that table, and may restrict the content of values associated with each key. The following keys must always be available, with the specified intended purposes:</p><ul><li><p><code>:title</code> A human-readable title the client can display instead of the channel's name. Especially useful for anonymous channels.</p></li><li><p><code>:news</code> Updates and latest news by channel administrators</p></li><li><p><code>:topic</code> A description of the general discussion topic of the channel</p></li><li><p><code>:rules</code> A Description of the rules that need to be followed by channel members</p></li><li><p><code>:contact</code> Information on how to reach contact persons for administrative problems</p></li><li><p><code>:url</code> Some kind of URL to a website representing the channel</p></li></ul><p>A new update called <code>channel-info</code> is introduced. It is a <code>channel-update</code> and holds a <code>keys</code> field that can either be <code>T</code> or a list of keys as symbols describing the info to fetch.</p><p>A new update called <code>set-channel-info</code> is introduced. It is a <code>channel-update</code> and a <code>text-update</code>, and holds a <code>key</code> field that must be a symbol describing the info to set.</p><p>A new error <code>no-such-channel-info</code> is introduced. It is an <code>update-failure</code> and contains the additional field <code>key</code>, which must hold a symbol.</p><p>A new error <code>malformed-channel-info</code> is introduced. It is an <code>update-failure</code>.</p><p>When the server receives a <code>channel-info</code> update, it must react as follows:</p><ol><li value="1"><p>For each of the requested keys, the server reacts as follows:</p><ol><li value="1"><p>If the key does not exist, the server replies with a <code>no-such-channel-info</code> failure with the according <code>key</code> set, and the <code>id</code> set to the <code>id</code> of the original update.</p></li><li value="2"><p>Otherwise, the server replies with a <code>set-channel-info</code> update with the same <code>id</code> as the request, <code>key</code> set to the current key being requested, and <code>text</code> being set to the key's value.</p></li></ol></li></ol><p>When the server receives a <code>set-channel-info</code> update, it must react as follows:</p><ol><li value="1"><p>If the specified <code>key</code> is not accepted by the server, it replies with a <code>no-such-channel-info</code> error and drops the update.</p></li><li value="2"><p>If the specified <code>text</code> is not of the correct format for the given <code>key</code>, it replies with a <code>malformed-channel-info</code> error and drops the update.</p></li><li value="3"><p>The internal channel metadata is updated to associate the given <code>key</code> with the given <code>text</code>.</p></li><li value="4"><p>The user's <code>set-channel-info</code> update is distributed to all users in the channel.</p></li></ol><h2 id="7. server management (shirakumo-server-management)">7. Server Management (shirakumo-server-management)</h2><p>Purpose: adds capabilities for administrative actions like deleting users and channels.</p><p>The server now holds an additional property, a <code>blacklist</code>, which is a set of usernames.</p><p>§4.1 is modified to include the following step after §4.1.4 (Checking for name validity):</p><ol><li value="1"><p>If the name is part of the <code>blacklist</code> set, a <code>too-many-connections</code> update is returned and the connection is closed.</p></li></ol><p>A new update called <code>kill</code> is introduced. It is a <code>target-update</code>. When the server receives a <code>kill</code> update, it must react as follows:</p><ol><li value="1"><p>If there is no user with a name corresponding to the <code>target</code>, the server replies with a <code>no-such-user</code> error and drops the update.</p></li><li value="2"><p>The user is removed from all channels it is in.</p></li><li value="3"><p>All connections the user is associated with are disconnected.</p></li><li value="4"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>destroy</code> is introduced. It is a <code>channel-update</code>. When the server receives a <code>destroy</code> update, it must react as follows:</p><ol><li value="1"><p>Unlike standard updates, the permission for the update must be checked against the primary channel, rather than the channel the update is targeting.</p></li><li value="2"><p>If there is no channel with a name corresponding to the <code>channel</code>, the server replies with a <code>no-such-channel</code> error and drops the update.</p></li><li value="3"><p>A <code>leave</code> update for the channel is sent to every user in the channel.</p></li><li value="4"><p>The channel is removed.</p></li><li value="5"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>ban</code> is introduced. It is a <code>target-update</code>. When the server receives a <code>ban</code> update, it must react as follows:</p><ol><li value="1"><p>The <code>target</code> is added to the <code>blacklist</code> set.</p></li><li value="2"><p>If a user with the <code>target</code> name is present, the user is removed from all channels it is in.</p></li><li value="3"><p>All connections the user is associated with are disconnected.</p></li><li value="4"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>unban</code> is introduced. It is a <code>target-update</code>. When the server receives an <code>unban</code> update, it must react as follows:</p><ol><li value="1"><p>The <code>target</code> is removed from the <code>blacklist</code> set.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>blacklist</code> is introduced. When a server receives a <code>blacklist</code> update, it must react as follows:</p><ol><li value="1"><p>The update's <code>target</code> field is set to the list of usernames contained in the <code>blacklist</code>.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><h2 id="8. pause (shirakumo-pause)">8. Pause (shirakumo-pause)</h2><p>Purpose: allows throttling high traffic channels to prevent frequent spam by users.</p><p>Channels have a new property, a &quot;pause&quot;, as well as a &quot;last update list&quot;. Delivery of any <code>channel-update</code> is modified as follows:</p><ol><li value="1"><p>If the <code>from</code> field of the update denotes a user whose entry in the &quot;last update list&quot; is a timestamp that's closer to the current timestamp than the channel's &quot;pause&quot;, the server responds with a <code>too-many-updates</code> error and drops the update.</p></li><li value="2"><p>The current timestamp is placed into the user's entry in the &quot;last update list&quot;.</p></li></ol><p>The &quot;pause&quot; is noted in seconds and has a default value of 0. The &quot;last update list&quot; has a default timestamp of 0 for users without an entry.</p><p>§5.4.1 (joining of a channel) is modified by adding the following extra step at the end:</p><ol><li value="1"><p>If the channel's &quot;pause&quot; property is greater than zero, a <code>pause</code> update is sent to the user with the <code>by</code> field set to the &quot;pause&quot; time.</p></li></ol><p>A new update called <code>pause</code> is introduced. It is a <code>channel-update</code> and has an additional field called <code>by</code>, which must contain an integer in the range [0,infinity[. When the server receives a <code>pause</code> update, it must react as follows:</p><ol><li value="1"><p>The channel's &quot;pause&quot; is set to &quot;by&quot;.</p></li><li value="2"><p>The update is distributed to all users in the channel.</p></li></ol><h2 id="9. quiet (shirakumo-quiet)">9. Quiet (shirakumo-quiet)</h2><p>Purpose: allows placing users onto a quiet list that prevents them from reaching any other users.</p><p>Channels have a new property, a &quot;quiet list&quot;. Delivery of any <code>channel-update</code> is modified as follows:</p><ol><li value="1"><p>If the <code>from</code> field of the update denotes a user that is on the &quot;quiet list&quot;, the update is sent back to that user, but not delivered to the rest of the channel.</p></li><li value="2"><p>Otherwise delivery proceeds as normal.</p></li></ol><p>A new update called <code>quiet</code> is introduced. It is a <code>target-update</code> and a <code>channel-update</code>. When the server receives a <code>quiet</code> update, it must react as follows:</p><ol><li value="1"><p>The target user is placed onto the &quot;quiet list&quot; of the channel.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>unquiet</code> is introduced. It is a <code>target-update</code> and a <code>channel-update</code>. When the server receives an <code>unquiet</code> update, it must react as follows:</p><ol><li value="1"><p>The target user is removed from the &quot;quiet list&quot; of the channel.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>quieted</code> is introduced. It is a <code>channel-update</code>. When the server receives a <code>quieted</code> update, it must react as follows:</p><ol><li value="1"><p>The update's <code>target</code> field is filled with a list of usernames on the channel's quiet list.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><h2 id="10. ip (shirakumo-ip)">10. IP (shirakumo-ip)</h2><p>Purpose: exposes IP address information and allows management of IPs.</p><p>Connections now have an additional property, the <code>ip</code>, which must be an IPv6 address. If the connection is established over IPv4, the <code>ip</code> should nevertheless be the IPv6 representation of this address.</p><p>The server has an additional property, an <code>ip-blacklist</code>, which is a set of IP addresses and masks as described below.</p><p>§4.1 is modified to include the following step before all others:</p><ol><li value="1"><p>If the IP address the connection is coming from matches one from the <code>ip-blacklist</code>, the connection is immediately dropped.</p></li></ol><p>An IP address <code>a</code> is considered the &quot;same&quot; as an IP address <code>b</code> under the mask <code>m</code>, if the bitwise AND of <code>a</code> and <code>b</code> with the bitwise inversion of <code>m</code> equals the same (<code>a &amp; !m == b &amp; !m</code>). The purpose of the mask is to allow addressing entire subnets.</p><p>A new update called <code>ip-ban</code> is introduced. It holds the required field <code>ip</code> and the optional field <code>mask</code>. If <code>mask</code> is not given, it should be assumed to be an IP address that is all 1s. Both the <code>ip</code> and <code>mask</code> field must be strings in either IPv4 or IPv6 format. When the server receives an <code>ip-ban</code> update, it must react as follows:</p><ol><li value="1"><p>If either <code>ip</code> or <code>mask</code> do not designate IPv4 or IPv6 addresses, a <code>bad-ip-format</code> failure is sent and the update is dropped.</p></li><li value="2"><p>Scan through the existing <code>ip-blacklist</code> and for each:</p><ol><li value="1"><p>if the IP matches <code>ip</code> under <code>mask</code>:<br>1. if the mask is greater (thus more general) than <code>mask</code>, the update is dropped<br>2. otherwise the entry is removed.</p></li></ol></li><li value="3"><p>The entry of <code>ip</code> and <code>mask</code> is added to the blacklist.</p></li><li value="4"><p>Any connection matching the new entry is dropped.</p></li><li value="5"><p>The update is sent back to the user.</p></li></ol><p>A new update called <code>ip-unban</code> is introduced. It holds the same fields as <code>ip-ban</code>. When the server receives an <code>ip-unban</code> update, it must react as follows:</p><ol><li value="1"><p>Scan through the existing <code>ip-blacklist</code> and for each:<br>1. if the IP matches <code>ip</code> under <code>mask</code>:</p><p>1. if the mask is greater than or equal to <code>mask</code>, the entry is removed.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><p>A new connection attribute called <code>shirakumo:ip</code> is introduced, which is a string showing the IP address from which the connection originates.</p><p>A new update called <code>ip-blacklist</code> is introduced. When a server receives an <code>ip-blacklist</code> update, it must react as follows:</p><ol><li value="1"><p>The update's <code>target</code> field is set to the list of IP addresses and masks contained in the <code>ip-blacklist</code>.</p></li><li value="2"><p>The update is sent back to the user.</p></li></ol><h2 id="11. bridge (shirakumo-bridge)">11. Bridge (shirakumo-bridge)</h2><p>Purpose: allows bridging chat channels from external services by sending messages on behalf of other users.</p><p>A new, optional field <code>:bridge</code> is added to all <code>channel-update</code>s. Handling of <code>channel-update</code>s is modified as follows, after the check of §5.1.6 (<code>channel</code> existence check):</p><ol><li value="1"><p>If the <code>bridge</code> field is set:<br>1. If the user is not in the channel, a <code>not-in-channel</code> failure is sent back and the update is dropped.<br>2. If the user does not have the permission to send a <code>bridge</code> update in the channel, an <code>insufficient-permissions</code> failure is sent back and the update is dropped.<br>3. The values of the <code>bridge</code> and <code>from</code> fields are swapped.<br>4. If the update would be delivered to all members of the channel ignoring all validity checks (it is not an update made for side-effects), then the update is sent to all members of the channel.<br>5. The update is dropped.</p></li></ol><p>The server may choose to discard the <code>bridge</code> field for any number of update types, but must in the very least support <code>message</code>.</p><p>A new update called <code>bridge</code> is introduced. It is a <code>channel-update</code>. When the server receives a <code>bridge</code> update, it must react as follows:</p><ol><li value="1"><p>The update is sent back to the user.</p></li></ol><h2 id="12. link (shirakumo-link)">12. Link (shirakumo-link)</h2><p>Purpose: allows storing data server-side to deliver it in a more efficient out-of-band fashion.</p><p>Clients and servers implementing this extension must also implement the <code>shirakumo-data</code> extension.</p><p>A new field called <code>shirakumo:link</code> is added to the <code>message</code> update.</p><p>When the server receives a <code>data</code> update, it must instead of §7.2.3 (distributing the update) act as follows:</p><ol><li value="1"><p>The data payload is saved somewhere, such that it is publicly accessible through an HTTP or HTTPS URL.</p></li><li value="2"><p>A new <code>message</code> update is generated from the <code>data</code> update, with the <code>text</code> being the public URL of the payload, and the <code>shirakumo:link</code> attribute containing the content-type.</p></li><li value="3"><p>The new <code>message</code> update is distributed to the channel.</p></li><li value="4"><p>The update is dropped</p></li></ol><p>The server may opt to make saved data payloads inaccessible after a time. The server should take care to generate URLs for the data payloads that are not guessable, which is to say a user cannot reliably generate URLs to access a payload. The server must serve the payload with the requested <code>content-type</code> set, and the <code>content-disposition</code> header may be set to include the requested filename in the update. The server must delete all data payloads if a channel is deleted (due to expiration or otherwise). The server may merge payloads that designate the same (byte-identical) files to the same URL.</p><p>When the client receives a <code>link</code> update, it must, as far as possible, embed the linked payload to display it directly. If it cannot display the payload directly, it may instead display the URL to which the link points.</p><h2 id="13. markup (shirakumo-markup)">13. Markup (shirakumo-markup)</h2><p>Purpose: allows using different markup languages to stylise the text in <code>text-update</code>s.</p><p><code>text-update</code>s all receive the following additional fields:</p><ul><li><p><code>rich</code> An AST containing a version of the text with markup information included. The <code>text</code> field must be set to the same text as this field, but with all markup information stripped away.</p></li></ul><p>When a client receives a <code>text-update</code> it should check the <code>rich</code> field and if it is set, the client should render the text according to the <code>rich</code> contents instead of the <code>text</code> contents. The client may ignore parts of the rich text if it considers the markup unsuitable. If the markup contains errors, the client must fall back to displaying the unformatted <code>text</code> instead.<br>The content in the <code>rich</code> field is a an AST according to the following BNF:</p><code style="display:block" class="code-block" data-language="BNF"><pre>rich            ::= group
content         ::= block | inline
block           ::= group
                  | paragraph
                  | unordered-list
                  | ordered-list
                  | code
                  | section
                  | image
                  | quote
                  | extended-block
group           ::= (:g () content*)
paragraph       ::= (:p () inline*)
unordered-list  ::= (:ul () group*)
                --- Wherein each group represents a list item
ordered-list    ::= (:ol () group*)
                --- Wherein each group represents a list item
code            ::= (:code string string)
                --- The first string designates the language (and thus syntax highlighting rules) for the code in the second string.
section         ::= (:section (integer inline*) content*)
                --- The integer designates the depth of the header, and its accompanying inline segments the header content.
image           ::= (:image target)
quote           ::= (:quote string content*)
                --- The string designating the quote author
extended-block  ::= (symbol list content*)
                --- A new block type defined in an extension. If the client does not support this block type, it should ignore the arguments list and treat the block as a group instead.
inline          ::= bold
                  | italic
                  | underline
                  | strikethrough
                  | monospace
                  | subtext
                  | supertext
                  | link
                  | color
                  | string
                  | extended-inline
bold            ::= (:b () inline*)
italic          ::= (:i () inline*)
underline       ::= (:u () inline*)
strikethrough   ::= (:s () inline*)
monospace       ::= (:m () inline*)
subtext         ::= (:sub () inline*)
supertext       ::= (:sup () inline*)
link            ::= (:link target inline*)
color           ::= (:color rgb inline*)
extended-inline ::= (symbol list inline*)
                --- A new inline type defined in an extension. If the client does not support this block type, it should ignore the arguments list and treat the block as a group instead.
rgb             ::= (float float float)
                --- An sRGB additive colour triplet, with 0 meaning no contribution and 1 meaning full contribution to the respective channel.
target          ::= string
                --- An URL encoded in the string.</pre></code><p>Each of the blocks in the tree thus has the general form of <code>(kind argument/s content*)</code> which should simplify the process of parsing it and turning it into a visual representation.</p><p>Clients should allow users to write the rich text using some form of surface syntax. The following are suggested possibilities for such surface syntax:</p><ul><li><p><code>html</code> HTML5 content</p></li><li><p><code>markless</code> <a class="external-link" href="https://shirakumo.github.io/markless">Markless</a></p></li><li><p><code>markdown</code> <a class="external-link" href="https://daringfireball.net/projects/markdown/syntax">Markdown</a></p></li><li><p><code>org</code> <a class="external-link" href="https://orgmode.org">org-mode</a></p></li><li><p><code>rest</code> <a class="external-link" href="https://docutils.readthedocs.io/en/sphinx-docs/user/rst/quickstart.html">reStructuredText</a></p></li></ul><p>Note that in combination with the <code>shirakumo-edit</code> extension, the client should also support the inverse operation of turning the AST back into the surface syntax for the user.</p><h2 id="14. user info (shirakumo-user-info)">14. User Info (shirakumo-user-info)</h2><p>Purpose: allows associating additional information with registered user accounts.</p><p>Profiles receive extra metadata fields that can be set set by users. To this end, profiles must keep a table of <code>metadata</code> to track. The server must restrict the valid keys in that table, and may restrict the content of values associated with each key. The following keys must always be available, with the specified intended purposes:</p><ul><li><p><code>:birthday</code> A textual description of the user's birthday.</p></li><li><p><code>:contact</code> Other contact methods, typically email addresses.</p></li><li><p><code>:location</code> A textual description of the user's real-world location.</p></li><li><p><code>:public-key</code> A PGP public key.</p></li><li><p><code>:real-name</code> The user's real-life name.</p></li><li><p><code>:status</code> May be <code>&quot;away&quot;</code>, or some arbitrary status description.</p></li></ul><p>The <code>user-info</code> update is changed to now hold an optional <code>info</code> field that is an association list.</p><p>A new update called <code>set-user-info</code> is introduced. It is a <code>text-update</code>. It holds a <code>key</code> field that must be a symbol describing the info to set.</p><p>A new error <code>no-such-user-info</code> is introduced. It is an <code>update-failure</code> and contains the additional field <code>key</code>, which must hold a symbol.</p><p>A new error <code>malformed-user-info</code> is introduced. It is an <code>update-failure</code>.</p><p>When the server receives a <code>user-info</code> update, it must react as follows, in addition to the standard behaviour described in §5.5.3:</p><ol><li value="1"><p>If the target user is not registered, this section is ignored.</p></li><li value="2"><p>For each user info key on the user's profile:</p><ol><li value="1"><p>A list composed of the key and the value of the field are added to the <code>info</code> field of the <code>user-info</code> reply.</p></li></ol></li></ol><p>When the server receives a <code>set-user-info</code> update, it must react as follows:</p><ol><li value="1"><p>If the target user is not registered, the server replies with a <code>no-such-profile</code> failure and drops the update.</p></li><li value="2"><p>If the specified <code>key</code> is not accepted by the server, it replies with a <code>no-such-user-info</code> error and drops the update.</p></li><li value="3"><p>If the specified <code>text</code> is not of the correct format for the given <code>key</code>, it replies with a <code>malformed-user-info</code> error and drops the update.</p></li><li value="4"><p>The internal user metadata is updated to associate the given <code>key</code> with the given <code>text</code>.</p></li><li value="5"><p>The <code>set-user-info</code> update is sent back.</p></li></ol><h2 id="15. shared identity (shirakumo-shared-identity)">15. Shared Identity (shirakumo-shared-identity)</h2><p>Purpose: allows creating tokens that let other users post updates on behalf of another (registered) user account.</p><p>User profiles now have an additional field, a &quot;lending map&quot;, which is a map associating keys (strings of at least 16 characters in length) to other usernames, and an &quot;identities list&quot;, which is a list of usernames they can send updates on behalf of.</p><p>§5.1.5 (<code>from</code> field check) is modified as follows:</p><ol><li value="1"><p>If the <code>from</code> field is in the connection's associated profile's &quot;identities list&quot; the <code>from</code> field check is elided.</p></li></ol><p>A new update called <code>share-identity</code> is introduced. When the server receives a <code>share-identity</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, a <code>no-such-profile</code> failure is sent back and the update is dropped.</p></li><li value="2"><p>If the profile already has too many identity shares, an <code>identity-already-used</code> failure is sent back and the update is dropped.</p></li><li value="3"><p>A new random key is generated and associated with <code>nil</code> in the profile's lending map.</p></li><li value="4"><p>The update is sent back with the <code>key</code> field set to the newly generated key.</p></li></ol><p>A new update called <code>unshare-identity</code> is introduced. When the server receives an <code>unshare-identity</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, a <code>no-such-profile</code> failure is sent back and the update is dropped.</p></li><li value="2"><p>If the <code>key</code> is not set, the profile's lending map is emptied and the user's name is removed from all identities lists.</p></li><li value="3"><p>Otherwise, the entry corresponding to the <code>key</code> is removed from the profile's lending map, and the user's name is removed from the identities list of the user who redeemed the key.</p></li><li value="4"><p>The update is sent back.</p></li></ol><p>A new update called <code>list-shared-identities</code> is introduced. When the server receives a <code>list-shared-identities</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, a <code>no-such-profile</code> failure is sent back and the update is dropped.</p></li><li value="2"><p>For every entry in the profile's lending map, the server gather's the key, as well as the username the associated connection is from (or <code>nil</code> if the key is not associated yet) into a list as for example:</p><code style="display:block" class="code-block"><pre>((&quot;aoeubcoeusasoet425&quot; &quot;test&quot;) (&quot;aoestuhau245757Saoeus&quot; NIL))</pre></code></li><li value="3"><p>The update is sent back, with the <code>shares</code> field set to the gathered list, and the <code>identities</code> field set to the user's identities list.</p></li></ol><p>A new update called <code>assume-identity</code> is introduced. It is a <code>target-update</code>. When the server receives an <code>assume-identity</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, a <code>no-such-profile</code> failure is sent back and the update is dropped.</p></li><li value="2"><p>If the target is already on the identities list of the profile, or the user is the target, an <code>identity-already-used</code> failure is sent back and the update is dropped.</p></li><li value="3"><p>If the <code>key</code> in the update is either not in the target profile's lending map, or the key is not associated with <code>nil</code>, an <code>identity-already-used</code> failure is sent back and the update is dropped.</p></li><li value="4"><p>The originating user is associated with the <code>key</code> in the target profile's map of shares, and the <code>target</code> is added to the originating profile's identities list.</p></li><li value="5"><p>The update is sent back to the originating connection.</p></li></ol><h2 id="16. icons (shirakumo-icons)">16. Icons (shirakumo-icons)</h2><p>Purpose: allows associating icons with channels and users.</p><p>This extension requires the <code>shirakumo-channel-info</code> or <code>shirakumo-user-info</code> extensions.</p><p>For channels and users, a new key type is introduced:</p><ul><li><p><code>:icon</code> The value of which must be a base64 encoded image file, with the content type prefixed like so: <code>content-type base64</code>.</p></li></ul><p>The server may reject images that are too large in dimension, or have a bad content-type. The server must in the very least support <code>image/png</code> and <code>image/gif</code> as content-types.</p><h2 id="17. signing (shirakumo-sign)">17. Signing (shirakumo-sign)</h2><p>Purpose: allows users to sign their messages with a PGP signature to ensure authenticity of the message.</p><p><code>update</code>s now have an additional field, <code>signature</code>. The signature is computed based on the following <code>utf-8</code> representation of updates:</p><code style="display:block" class="code-block"><pre>UPDATE   ::= OBJECT NULL
OBJECT   ::= '(' SYMBOL (SPACE KEYWORD SPACE EXPR)* ')'
EXPR     ::= STRING | LIST | SYMBOL | NUMBER
STRING   ::= '&quot;' ('\' '&quot;' | '\' '\' | !('&quot;' | NULL))* '&quot;'
LIST     ::= '(' (EXPR (SPACE EXPR)*)? ')'
SYMBOL   ::= KEYWORD | NAME | NAME ':' NAME
KEYWORD  ::= ':' NAME
NUMBER   ::= '0..9'+ ( '.' '0..9'*)?
NAME     ::= ('\' '\' | '\' TERMINAL | !(TERMINAL | NULL))+
TERMINAL ::= (':' | ' ' | '&quot;' | '.' | '(' | ')')
SPACE    ::= U+0020
NULL     ::= U+0000</pre></code><p>This is equivalent to the standard wire format structure and the recommended way of printing, but enforces single space between tokens, no use of backslash escapes unless necessary, and forces a leading digit on numbers, essentially eliminating all ambiguities in the syntax. Additional constraints on printing the update's fields apply:</p><ul><li><p>The fields must be printed by sorting them according to their unicode codepoints, meaning order is determined by comparing each codepoint in two candidates in turn and sorting the lower codepoint to be before the higher codepoint.</p></li><li><p>The <code>signature</code> field must be omitted.</p></li><li><p>The <code>clock</code> and <code>from</code> fields must be present.</p></li></ul><p>As an example, printing a standard <code>message</code> update would look as follows:</p><code style="display:block" class="code-block"><pre>(message :channel &quot;test&quot; :clock 424742 :id 0 :from &quot;tester&quot; :text &quot;something&quot;)</pre></code><p>When the server receives a message with the <code>signature</code> field set, the following constraints apply to §5.1:</p><ul><li><p>If the <code>from</code> or <code>clock</code> fields are not set, a <code>malformed-update</code> update is sent back and the request is dropped.</p></li><li><p>The server must not adjust the <code>clock</code> value.</p></li></ul><p>After the signature has been computed from the printed representation, the client should attach it to the <code>signature</code> field of the update and send it to the server. Clients may then verify the signature using the PGP public key of the user, if known. It is recommended for clients that support this extension to give a visual indicator for signed updates, especially if the signature verification should fail.</p><p>A user's pgp key may be retrieved out of band, or using the <code>shirakumo-user-info</code> <code>:public-key</code> field if available.</p><h2 id="18. history (shirakumo-history)">18. History (shirakumo-history)</h2><p>Purpose: allows users to search through the history of a channel to find relevant messages.</p><p>In order to facilitate this, the server must now keep updates in storage, potentially indefinitely. The server is only required to keep updates of type <code>message</code>, but may keep other updates of type <code>channel-update</code> as well. Of each update stored, the server must store at least the fields <code>id</code>, <code>from</code>, <code>clock</code>, and <code>channel</code>. It may store additional fields, and it may also drop them. This means that the server is not required to fully keep update identity.</p><p>A new update type called <code>search</code> is introduced. It is a <code>channel-update</code>, and holds three additional fields, <code>results</code>, <code>offset</code>, and <code>query</code>. The <code>query</code> field must hold a list of initargs, meaning alternating symbols and values to describe the keys to match. When the server receives a <code>search</code> update, it must proceed as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>It gathers a list of all recorded updates that were posted to the channel specified in the <code>search</code> update.</p></li><li value="3"><p>For each update in the list:</p><ol><li value="1"><p>The <code>query</code> field is compared against the update by comparing each initarg in the query to the corresponding field in the update, based on the field's type:<br>- <code>time</code>: The query value must be a list of two elements, being either <code>T</code> or a <code>time</code> value, with <code>T</code> being &quot;any time&quot;. The first element designates the lowest possible time to match, and the second the highest possible time to match. This thus designates a range of time values, with the bounds being inclusive.<br>- <code>number</code>: The query value must be a number, and is compared to the candidate value by a standard number equality test.<br>- <code>symbol</code>: The query value must be a symbol, and matches if the candidate is the same symbol.<br>- <code>list</code>: The query value must be another list, and matches the candidate if all of the elements of the query appear in the candidate list, regardless of order. Elements are compared recursively.<br>- <code>string</code>: The query value must be a list of strings, each of them designating a matching spec:</p><p>::<br>MATCH        ::= CHAR*<br>CHAR         ::= ESCAPED | ANY | NONE-OR-MORE | character<br>ESCAPED      ::= '' character<br>ANY          ::= '_'<br>NONE-OR-MORE ::= '*'<br>::<br>Where <code>ANY</code> stands for any particular character, and <code>NONE-OR-MORE</code> stands for an arbitrary number of arbitrary characters. When matching a single &quot;character&quot; with <code>ANY</code>, the Unicode Collation Algorithm rules must be followed. The query value matches if at least one of its strings matches.</p></li><li value="1"><p>Should any of the fields not match, the update is removed from the list.</p></li></ol></li><li value="4"><p>The list of updates is sorted in order of their <code>clock</code> with the lowest being first.</p></li><li value="5"><p>The first N updates are dropped off the list, where N corresponds to number in the <code>offset</code> field. If <code>offset</code> is not specified, 0 is assumed.</p></li><li value="6"><p>The first N updates are kept and the rest dropped off the list, where N is an internal server limit, which must be at least 50.</p></li><li value="7"><p>The list of updates is split into multiple lists such that each list can be reliably sent back to the user.</p></li><li value="8"><p>For each list of updates, the list is put into the <code>search</code> update's <code>results</code> field and the update is sent back.</p></li></ol><p>The server should provide a means to delete updates from its history to ensure confidential and private information can be removed and is not preserved indefinitely. If the <code>search</code> update has a permission of <code>NIL</code> (being denied to everyone) in a channel, the history does not need to be recorded. If a channel expires, its history must be deleted.</p><p>The client should provide a convenient means to perform a search query. To this end we also specify a suggested means of formatting queries for end-user input. The query should be specified as freeform text, with the following queryspec format:</p><code style="display:block" class="code-block"><pre>QUERY    ::= (FIELD | TOKEN)+
FIELD    ::= WORD ':' TOKEN
TOKEN    ::= STRING | WORD
STRING   ::= '&quot;' ('\' char | !'&quot;') '&quot;'
WORD     ::= (!TERMINAL)+
TERMINAL ::= ':' | ' ' | '&quot;'</pre></code><p>Where a <code>FIELD</code> specifies a specific field to match in an update, with the <code>WORD</code> designating the initarg and the <code>TOKEN</code> the value. Special 'virtual fields' should be added:</p><ul><li><p><code>after</code> Designates the former element in a <code>time</code> match for the <code>clock</code> field. If only <code>after</code> is specified, the latter element is <code>T</code>. The actual format of the <code>TOKEN</code> does not have to be an integer, but should be some human-readable datestring.</p></li><li><p><code>before</code> Designates the latter element in a <code>time</code> match for the <code>clock</code> field. If only <code>before</code> is specified, the former element is <code>T</code>. The actual format of the <code>TOKEN</code> does not have to be an integer, but should be some human-readable datestring.</p></li><li><p><code>in</code> Designates the <code>channel</code> field. If not present, the client should infer the channel to use from the current channel.</p></li></ul><p>The <code>TOKEN</code> should be parsed according to the standard wire format, unless more specific and convenient ways of specifying a fitting value are available. Each <code>TOKEN</code> than is not part of a <code>FIELD</code>, should designate a matching spec to be part of the list of matching specs for the <code>text</code> field.</p><p>In other words, the following queryspec:</p><code style="display:block" class="code-block"><pre>from:tester after:2020-01-01 this &quot;that is&quot; in:test</pre></code><p>Should be translated into a search update like this:</p><code style="display:block" class="code-block"><pre>(search
 :id 0
 :channel &quot;test&quot;
 :query (:from &quot;tester&quot;
         :clock (3786825600 T)
         :text (&quot;this&quot; &quot;that is&quot;)))</pre></code><p>The client should also offer an easy way to page through the results using the <code>offset</code> field. The end of the paging may be detected should the server ever return less than 50 results.</p><p>If the server also supports the <code>shirakumo-backfill</code> extension, it may deliver backfill using the history, even if users were not previously in the channel. This poses a privacy risk, but as search is not otherwise restricted anyway, it makes no difference.</p><h2 id="19. block (shirakumo-block)">19. Block (shirakumo-block)</h2><p>Purpose: allows users to block other users, preventing seeing their updates. Having this property server-side instead of client-side means it is automatically persisted and synchronised.</p><p>Profiles now have a new field: a block list. This is a list of usernames.</p><p>Whenever an update is distributed over a channel, the following behaviour must be followed:</p><ol><li value="1"><p>For each (target) user in the channel:</p><ol><li value="1"><p>If the user noted in the <code>from</code> field of the update is *not* the block list of the target user's profile:</p></li><li value="2"><p>The update is sent to all connections associated with the target user.</p></li></ol></li></ol><p>A new update type called <code>block</code> is introduced. It is a <code>target-update</code>. When the server receives a <code>block</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, the server replies with a <code>no-such-profile</code> failure and drops the update.</p></li><li value="2"><p>The username from the <code>target</code> field is added to the profile's block list if it isn't present already.</p></li><li value="3"><p>The update is sent back to the user.</p></li></ol><p>A new update type called <code>unblock</code> is introduced. It is a <code>target-update</code>. When the server receives an <code>unblock</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, the server replies with a <code>no-such-profile</code> failure and drops the update.</p></li><li value="2"><p>The username from the <code>target</code> field is removed to the profile's block list.</p></li><li value="3"><p>The update is sent back to the user.</p></li></ol><p>A new update type called <code>blocked</code> is introduced. When the server receives a <code>blocked</code> update, it must react as follows:</p><ol><li value="1"><p>If the user is not registered, the server replies with a <code>no-such-profile</code> failure and drops the update.</p></li><li value="2"><p>The update's <code>target</code> field is filled with a list of usernames on the sending user profile's block list.</p></li><li value="3"><p>The update is sent back to the user.</p></li></ol><h2 id="20. reactions (shirakumo-reactions)">20. Reactions (shirakumo-reactions)</h2><p>Purpose: allows users to react to messages without sending a new message.</p><p>This requires clients to implement unique IDs when sending an update. They do not need to be globally unique, but should be unique to that user, regardless of connection used.</p><p>A new update type called <code>react</code> is introduced. It is a <code>channel-update</code> and carries the additional fields <code>update-id</code>, <code>target</code>, and <code>emote</code>. <code>update-id</code> must be an <code>id</code> used in a message previously sent by the <code>target</code> user in the <code>channel</code>. <code>emote</code> must either be unicode characters from the emoji block, or if the <code>shirakumo-emote</code> extension is supported, the name of an emote.</p><p>When the server receives a <code>react</code> update, it must act as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the <code>emote</code> does not contain valid text as noted above, a <code>malformed-update</code> failure is sent back and the update is dropped.</p></li><li value="3"><p>The user's <code>react</code> update is distributed to all users in the channel.</p></li></ol><p>For each visible update the client should now keep track of a table of reactions from emotes to lists of users that used the emote on the referenced update. When the client receives a <code>react</code> update, it should update the table as follows:</p><ol><li value="1"><p>If the emote is not in the table yet, a new entry is added, associated to an empty list.</p></li><li value="2"><p>If the <code>from</code> user is not in the list of users, the user is added to it. Otherwise the user is removed from it.</p></li><li value="3"><p>The table of emotes is displayed in the vicinity of the referenced update as a list of emotes and counts of users having used said emote. If applicable, the list of users having used the emote should also be displayed via a hover action.</p></li></ol><p>If a <code>react</code> update references an update that is not known to the client, it is ignored.</p><h2 id="21. replies (shirakumo-replies)">21. Replies (shirakumo-replies)</h2><p>Purpose: allows specifying another message that a message is in reply to.</p><p>This requires clients to implement unique IDs when sending an update. They do not need to be globally unique, but should be unique to that user, regardless of connection used.</p><p>A new field is added to the <code>message</code> update: <code>reply-to</code>. The field should hold a list of two values, a username and an id, identifying the message this message is in reply to.</p><p>The server does not have to do anything special aside from transmitting the field.</p><p>When the client receives a <code>message</code> update with the <code>reply-to</code> field set, it should display the message in relation to the original message, by quoting it or linking back to it in some manner.</p><h2 id="22. last read (shirakumo-last-read)">22. Last Read (shirakumo-last-read)</h2><p>Purpose: allows tracking which message in a channel was last read across connections.</p><p>This requires the server to track a new per-user property in each channel: 'last read message', which is a tuple of a message ID and a username.</p><p>A new update is introduced called <code>last-read</code>, which is a <code>channel-update</code>. It has two additional optional fields, <code>update-id</code>, and <code>target</code>. <code>update-id</code> must be an <code>id</code> used in a message previously sent by the <code>target</code> user in the <code>channel</code>.</p><p>When the server receives a <code>last-read</code> update, it proceeds as follows:</p><ol><li value="1"><p>If the user is not registered, an error of type <code>no-such-profile</code> is sent back and the update is dropped.</p></li><li value="2"><p>If the <code>update-id</code> and <code>target</code> fields are set:</p><p>. The id and target are stored for the user's 'last read message' in the associated channel.<br>. The update is sent back to the user.</p></li><li value="3"><p>Otherwise:</p><p>. The update is modified to use the 'last read message' information to fill in the <code>update-id</code> and <code>target</code> fields.<br>. The update is sent back to the sending connection.</p></li></ol><p>If the user leaves a channel, the 'last read message' tuple may be unset. If a user enters a channel, the 'last read message' tuple must be set to the <code>enter</code> message's <code>id</code> and <code>from</code> fields, should the 'last read message' tuple be unset.</p><h2 id="23. typing (shirakumo-typing)">23. Typing (shirakumo-typing)</h2><p>Purpose: allows specifying when a user is in the process of typing a message.</p><p>A new update is introduced called <code>typing</code>, which is a <code>channel-update</code>.</p><p>When the server receives a <code>typing</code> update, it proceeds as follows:</p><ol><li value="1"><p>The update is distributed to all users in the channel.</p></li></ol><p>When a client receives a <code>typing</code> update, it should notify the user that the update's sender is typing something. If no new <code>typing</code> update is received within the next 5 seconds, the typing notification should be cleared.</p><p>When the client's user types, the client may send a <code>typing</code> update to the current channel, as long as the previous <code>typing</code> update was sent more than 4 seconds ago.</p><h2 id="24. otp (shirakumo-otp)">24. OTP (shirakumo-otp)</h2><p>Purpose: allows using one-time-passwords to authenticate against a user account.</p><p>The <code>register</code> update is changed to include an additional field called <code>otp-key</code> which is a <code>string</code> and contains some implementation-specific key used to determine validity of future OTP tokens.</p><p>When the server receives a <code>register</code> update with the <code>otp-key</code> field set, it should act as follows:</p><ol><li value="1"><p>If the <code>otp-key</code> string is empty (zero length):<br>1. It deactivates one-time-password authentication for the account.<br>2. Otherwise, it stores the <code>otp-key</code> and enables the account for one-time-password authentication. If the key is invalid, an <code>invalid-otp-key</code> failure is returned and the update is dropped.</p></li><li value="2"><p>It sends the update back to the user.</p></li></ol><p>The <code>connect</code> update is changed to include an additional field called <code>otp-token</code> which is a <code>string</code> and contains some implementation-specific one-time-password token obtained through the implementation's specified password generation mechanism.</p><p>When the server receives a <code>connect</code> update for an account for which one-time-password authentication has been enabled, an additional verification step is inserted after §4.1.7:</p><ol><li value="1"><p>The <code>otp-token</code> is verified for validity against the stored <code>otp-key</code> by an implementation-specific mechanism. If the token is not valid or not provided, an <code>invalid-password</code> update is returned and the connection is closed.</p></li></ol><h2 id="25. roles (shirakumo-roles)">25. Roles (shirakumo-roles)</h2><p>Purpose: allows grouping sets of permissions into roles for easier management.</p><p>A new server-side object is introduced called <code>role</code> with the following attributes:</p><ul><li><p><code>name</code> The name of the role, which underlies the same restrictions as usernames described by §2.2.1</p></li><li><p><code>permissions</code> A map assigning update types to be either granted (<code>T</code>), denied (<code>NIL</code>), or in the default, ignored.</p></li><li><p><code>members</code> A set of usernames belonging to this role.</p></li></ul><p>The channel object is updated to have a <code>roles</code> field, which maps a role name to a <code>role</code> object.</p><p>The following default set of role objects should be added to every newly created channel:</p><ul><li><p><code>name</code>: <code>admin</code><br><code>permissions</code>: <code>((kick T) (pull T) (set-channel-info T) (destroy T) (quiet T) (unquiet T) (quieted T) (bridge T) (permissions T) (grant T) (deny T) (role T) (delete-role T) (assign-role T) (remove-role T) (roles T))</code><br><code>members</code>: <code>(creator)</code></p></li><li><p><code>name</code>: <code>moderator</code><br><code>permissions</code>: <code>((kick T) (pull T) (set-channel-info T) (quiet T) (unquiet T) (quieted T) (roles T))</code><br><code>members</code>: <code>()</code></p></li><li><p><code>name</code>: <code>banned</code><br><code>permissions</code>: <code>((join NIL) (message NIL) (kick NIL) (pull NIL) (permissions NIL) (grant NIL) (deny NIL) (users NIL) (channels NIL) (backfill NIL) (data NIL) (emote NIL) (edit NIL) (channel-info NIL) (set-channel-info NIL) (destroy NIL) (pause NIL) (quiet NIL) (unquiet NIL) (quieted NIL) (bridge NIL) (search NIL) (react NIL) (last-read NIL) (typing NIL) (role NIL) (delete-role NIL) (assign-role NIL) (remove-role NIL) (roles NIL))</code></p></li></ul><p>Update permissions checking (§5.1.8) is extended as follows:</p><ol><li value="1"><p>If the user has an entry in the channel's <code>permissions</code> set for the update type proceed as normal and skip this extra behaviour.</p></li><li value="2"><p>For each <code>role</code>:</p></li><li value="3"><p>If the update type does not have an entry in the <code>permissions</code> set of the <code>role</code>, skip.</p></li><li value="4"><p>If the user is not a part of the <code>members</code> set of the <code>role</code>, skip.</p></li><li value="5"><p>If the permission is set to <code>NIL</code> (deny), an <code>insufficient-permissions</code> update is sent back and the request is dropped.</p></li><li value="6"><p>If the permission is set to <code>T</code> (grant), this is remembered.</p></li><li value="7"><p>When each <code>role</code> has been processed and there was a <code>grant</code> permission, the update is permitted.</p></li><li value="8"><p>Otherwise the channel's default permission entry for the update type is considered.</p></li></ol><p>A new update is introduced called <code>role-update</code>, which is a <code>channel-update</code>. It is an abstract supertype and has no behaviour of its own.</p><p>A new update is introduced called <code>role</code>, which is a <code>role-update</code>.</p><p>When the server receives a <code>role</code> update, it proceeds as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the <code>permissions</code> field is unset and no corresponding <code>role</code> exists for the channel, a <code>no-such-role</code> update is sent back and the request is dropped.</p></li><li value="3"><p>If the <code>permissions</code> field is set and no corresponding role exists for the channel, the <code>role</code> object is created for the channel.</p></li><li value="4"><p>If the <code>permissions</code> field is set, the <code>permissions</code> field of the corresponding <code>role</code> is updated to match.</p></li><li value="5"><p>The <code>permissions</code> field of the update is set to match the <code>permissions</code> of the corresponding <code>role</code>.</p></li><li value="6"><p>The update is sent back.</p></li></ol><p>A new update is introduced called <code>delete-role</code>, which is a <code>role-update</code>.</p><p>When the server receives a <code>delete-role</code> update, it proceeds as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If no corresponding <code>role</code> exists for the channel, a <code>no-such-role</code> update is sent back and the request is dropped.</p></li><li value="3"><p>The corresponding <code>role</code> object is removed from the channel.</p></li><li value="4"><p>The update is sent back.</p></li></ol><p>A new update is introduced called <code>assign-role</code>, which is a <code>role-update</code> and a <code>target-update</code>.</p><p>When the server receives an <code>assign-role</code> update, it proceeds as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If no corresponding <code>role</code> exists for the channel, a <code>no-such-role</code> update is sent back and the request is dropped.</p></li><li value="3"><p>The <code>target</code> username is added to the set of <code>members</code> of the role if it does not already exist.</p></li><li value="4"><p>The update is sent back.</p></li></ol><p>A new update is introduced called <code>remove-role</code>, which is a <code>role-update</code> and a <code>target-update</code>.</p><p>When the server receives an <code>remove-role</code> update, it proceeds as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If no corresponding <code>role</code> exists for the channel, a <code>no-such-role</code> update is sent back and the request is dropped.</p></li><li value="3"><p>The <code>target</code> username is removed to the set of <code>members</code> of the role if it exists.</p></li><li value="4"><p>The update is sent back.</p></li></ol><p>A new update is introduced called <code>roles</code>, which is a <code>channel-update</code>.</p><p>When the server receives an <code>roles</code> update, it proceeds as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the <code>target</code> field is set, the <code>roles</code> field is populated with the set of <code>role</code> <code>name</code>s for which the <code>target</code> is a part of the <code>members</code> set.</p></li><li value="3"><p>If the <code>target</code> field is unset, the <code>roles</code> field is populated with the set of <code>role</code> <code>name</code>s.</p></li><li value="4"><p>The update is sent back.</p></li></ol></article>