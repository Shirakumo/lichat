<article><style>article{
    max-width: 1000px;
    font-size: 14pt;
    font-family: sans-serif;
    margin: 3em auto;
}

article h1{
    text-align: center;
    font-size: 2em;
}

article img{
    margin: 0 auto;
    max-width: 100%;
}

article blockquote{
    border-left: 0.2em solid gray;
    margin-left: 1em;
    padding-left: 1em;
}

article figcaption{
    padding: 0.2em 1em;
    background: #E0E0E0;
}

article code{
    background: #F0F0F0;
    padding: 0 0.1em;
}

article .code-block{
    padding: 0.1em 0.5em;
    overflow-x: auto;
}</style><h1 id="lichat protocol specification">Lichat Protocol Specification</h1><h2 id="1. wire format &amp; data types">1. Wire Format &amp; Data Types</h2><p>The Lichat protocol defines the following basic data type hierarchy:</p><ul><li><p><code>number</code></p><ul><li><p><code>integer</code></p><ul><li><p><code>time</code> An integer representing time as the number of seconds since 1900.1.1 1:0:0 UTC.</p></li></ul></li><li><p><code>float</code></p></li><li><p><code>id</code></p></li></ul></li><li><p><code>symbol</code></p><ul><li><p><code>keyword</code> A symbol whose package is <code>keyword</code>.</p></li><li><p><code>boolean</code></p><ul><li><p><code>null</code> The symbol <code>NIL</code> from the <code>lichat</code> package.</p></li><li><p><code>true</code> The symbol <code>T</code> from the <code>lichat</code> package.</p></li></ul></li></ul></li><li><p><code>list</code></p><ul><li><p><code>(list type)</code> A list with each element being of type <code>type</code>.</p></li></ul></li><li><p><code>string</code></p><ul><li><p><code>username</code> See §2.2.1</p></li><li><p><code>channelname</code> See §2.4.4</p></li><li><p><code>password</code> See §2.3.1</p></li></ul></li><li><p><code>object</code></p></li></ul><p>The wire format is based on UTF-8 character streams on which objects are serialised in a secure, simplified s-expression format. The format is as follows:</p><code style="display:block" class="code-block" data-language="NF"><pre>UPDATE   ::= OBJECT NULL
OBJECT   ::= '(' WHITE* SYMBOL (WHITE+ SYMBOL WHITE+ EXPR)* WHITE* ')'
EXPR     ::= STRING | LIST | SYMBOL | NUMBER
STRING   ::= '&quot;' ('\' ANY | !('&quot;' | NULL))* '&quot;'
LIST     ::= '(' WHITE* (EXPR (WHITE+ EXPR)*)? WHITE* ')'
SYMBOL   ::= KEYWORD | NAME | NAME ':' NAME
KEYWORD  ::= ':' NAME
NUMBER   ::= '0..9'+ ( '.' '0..9'*)? | '.' '0..9'*
NAME     ::= (('\' ANY) | !(TERMINAL | NULL))+
TERMINAL ::= (':' | ' ' | '&quot;' | '.' | '(' | ')')
WHITE    ::= U+0009 | U+000A | U+000B | U+000C | U+000D | U+0020
NULL     ::= U+0000
ANY      ::= !NULL</pre></code><h3 id="1.1 symbols">1.1 Symbols</h3><p>A symbol is an object with a &quot;name&quot; that is home to a &quot;package&quot;. A &quot;package&quot; is a simple collection of symbols. Symbols are uniquely identified by their name and package, and no two symbols with the same name may exist in the same package. The package and symbol names are case-insensitive, and two names are considered the same if they match after both have been transformed to lower case.</p><p>This protocol specifies two core packages: <code>lichat</code> and <code>keyword</code>. Symbols that come from the <code>lichat</code> package must be printed without the package name prefix. Symbols from the <code>keyword</code> package must be printed by their name only prefixed by a <code>:</code>. Every other symbol must be prefixed by the symbol's package's name followed by a <code>:</code>. </p><p>When a symbol is read, it is checked whether it exists in the corresponding package laid out by the previous rules. If it does not exist, it may be substituted for a placeholder symbol. Servers must take special care not to keep symbol objects they don't know around, to avoid letting clients overload the server's memory with inexistent symbols.</p><h3 id="1.2 objects">1.2 Objects</h3><p>Special care must be taken when <code>object</code>s are read from the wire. An error must be generated if the object is malformed by either a non-symbol in the first place of its list, imbalanced key/value pairs in the tail, or non-keywords in the key position. An error must also be generated if the symbol at the first position does not name a class that is a subclass of <code>object</code>. Finally, any field whose value is specified as <code>nil</code> on the wire can be equated with being unset, and vice versa when printing an object if an optional field is unset or <code>nil</code>, it may be omitted from the wire representation.</p><h3 id="1.3 null characters">1.3 Null Characters</h3><p>Null characters (<code>U+0000</code>) must not appear anywhere within a wireable. If a string were to contain null characters, they must be filtered out. If a symbol were to contain null characters, the message may not be put to the wire.</p><h3 id="1.4 machine-readable definition">1.4 Machine-Readable Definition</h3><p>All object types are specified in <a class="external-link" href="lichat.sexpr">lichat.sexpr</a> in a machine-readable format based on the above wire format. The same format <em>should</em> also be used by extension providers to define their extensions to the protocol. The definitions can be parsed by parsing the file into a sequence of <code>EXPR</code>s, each being further parsed according to the following <code>DEFINITION</code> rule:</p><code style="display:block" class="code-block" data-language="NF"><pre>DEFINITION           ::= PACKAGE | OBJECT | EXTENSION
PACKAGE              ::= (define-package PACKAGE-NAME)
PACKAGE-NAME         ::= STRING
OBJECT               ::= (define-object CLASS-NAME (SUPERCLASS*) SLOT*)
CLASS-NAME           ::= SYMBOL
SUPERCLASS           ::= SYMBOL
SLOT                 ::= (SLOT-NAME TYPE OPTIONAL?)
FIELD-NAME           ::= SYMBOL
TYPE                 ::= number | integer | time | float | id | symbol | keyword
                       | boolean | null | true | list | (list TYPE) | string
                       | username | channelname | password | object | T
OPTIONAL             ::= :optional
EXTENSION            ::= (define-extension EXTENSION-NAME EXTENSION-DEFINITION*)
EXTENSION-NAME       ::= STRING
EXTENSION-DEFINITION ::= OBJECT | OBJECT-EXTENSION
OBJECT-EXTENSION     ::= (define-object-extension CLASS-NAME (SUPERCLASS*) SLOT*)</pre></code><p>The meaning of each definition is as follows:</p><ul><li><p><code>package</code> Introduces a new, known package with the <code>PACKAGE-NAME</code> as its name.</p></li><li><p><code>object</code> Introduces a new object type using <code>CLASS-NAME</code> as its name. Each <code>SUPERCLASS</code> must name an object type that was previously introduced, and whose fields <em>and behaviour</em> should be inherited. Each <code>SLOT</code> defines a slot that the object holds in addition to the inherited ones. If the slot definition includes the <code>:optional</code> keyword, the slot may be omitted when serialising to the wire. If <code>:optional</code> is not included, the slot <em>must</em> be serialised. When translating from the wire, an omitted <code>:optional</code> slot should be initialised to an empty value. An omitted non-<code>:optional</code> slot must result in a <code>malformed-update</code> error.</p></li><li><p><code>extension</code> Introduces a protocol extension of the given <code>EXTENSION-NAME</code>. Its body includes new definitions that need to be added if the extension is to be supported.</p></li><li><p><code>object-extension</code> Changes an existing object type of <code>CLASS-NAME</code> by either introducing additional <code>SUPERCLASS</code>es, or introducing additional <code>SLOT</code> definitions on the object. Note that in order to stay backwards compatible, every slot specified via an <code>object-extension</code> must be <code>:optional</code>.</p></li></ul><h2 id="2. server objects">2. Server Objects</h2><p>The server must keep track of a number of objects that are related to the current state of the chat system. The client may also keep track of some of these objects for its own convenience.</p><h3 id="2.1 connection">2.1 Connection</h3><p>Each client is connected to the server through a <code>connection</code> object. Each connection in turn is tied to a user object. A user may have up to an implementation-dependant number of connections at the same time.</p><h3 id="2.2 user">2.2 User</h3><p><code>user</code>s represent participants on the chat network. A user has a globally unique name and a number of connections that can act as the user. Each user can be active in a number of channels, the maximal number of which is implementation-dependant. A user must always inhabit the primary channel. A user may have a profile object associated with it. When such a profile exists, the user is considered to be &quot;registered.&quot; The server itself must also have an associated user object, the name of which is up to the specific server instance.</p><h4 id="2.2.1 user name constraints">2.2.1 User Name Constraints</h4><p>A user's name must be between 1 and 32 characters long, where each character must be from the Unicode general categories Letter, Mark, Number, Punctuation, and Symbol, or be a Space (<code>U+0020</code>). The name must not begin or end with <br>with Spaces (<code>U+0020</code>), nor may two Spaces be consecutive. Two user names are considered the same if they are the same length and each code point matches case-insensitively.</p><h3 id="2.3 profile">2.3 Profile</h3><p>The <code>profile</code> primarily exists to allow end-users to log in to a user through a password and thus secure the username from being taken by others. A profile has a maximal lifetime. If the user associated with the profile has not been used for longer than the profile's lifetime, the profile is deleted.</p><h4 id="2.3.1 password constraints">2.3.1 Password Constraints</h4><p>A profile's password must be at least 6 characters long. It may contain any kind of character that is not Null (<code>U+0000</code>).</p><h3 id="2.4 channel">2.4 Channel</h3><p><code>channel</code>s represent communication channels for users over which they can send messages to each other. A channel has a set of permission rules that constrain what kind of updates may be performed on the channel by whom. There are three types of channels that only differ in their naming scheme and their permissions.</p><h4 id="2.4.1 primary channels">2.4.1 Primary Channels</h4><p>Exactly one of these must exist on any server, and it must be named the same as the server's user. All users that are currently connected to the server must inhabit this channel. The channel may not be used for sending messages by anyone except for system administrators or the server itself. The primary channel is also used for updates that are &quot;channel-less,&quot; to check them for permissions.</p><h4 id="2.4.2 anonymous channels">2.4.2 Anonymous Channels</h4><p>Anonymous channels must have a random name that is prefixed with an <code>@</code>. Their permissions must prevent users that are not already part of the channel from sending <code>join</code>, <code>channels</code>, <code>users</code>, or any other kind of update to it, thus essentially making it invisible safe for specially invited users.</p><h4 id="2.4.3 regular channels">2.4.3 Regular Channels</h4><p>Any other channel is considered a &quot;regular channel&quot;.</p><h4 id="2.4.4 channel name constraints">2.4.4 Channel Name Constraints</h4><p>The names of channels are constrained in the same way as user names. See §2.2.1.</p><h3 id="2.5 permission rules">2.5 Permission Rules</h3><p>A permission rule specifies the restrictions of an update type on who is allowed to perform the update on the channel. The structure is as follows:</p><code style="display:block" class="code-block" data-language="NF"><pre>RULE     ::= (type EXPR)
EXPR     ::= t | nil | EXCLUDE | INCLUDE
EXCLUDE  ::= (- username*)
INCLUDE  ::= (+ username*)</pre></code><p>Where <code>type</code> is the name of an update class, and <code>username</code> is the name of a user object. <code>t</code> is the symbol <code>T</code> and indicates &quot;anyone&quot;. <code>nil</code> is the symbol <code>NIL</code> and indicates &quot;no one&quot;. The <code>INCLUDE</code> expression only allows users whose names are listed to perform the action. The <code>EXCLUDE</code> expression allows anyone except users whose names are listed to perform the action. The expression <code>t</code> is thus equivalent to <code>(-)</code> and the expression <code>nil</code> is equivalent to <code>(+)</code>.</p><h2 id="3. general interaction">3. General Interaction</h2><p>The client and the server communicate through <code>update</code> objects over a connection. Each such object that is issued from the client must contain a unique <code>id</code>. This is important as the ID is reused by the server in order to communicate replies. The client can then compare the ID of the incoming updates to find the response to an earlier request, as responses may be reordered or delayed. The server does not check the ID in any way– uniqueness and avoidance of clashing is the responsibility of the client. Each update <em>should</em> also contain a <code>clock</code> slot that specifies the time of sending. This is used to calculate latency and potential connection problems. If no clock is specified, the server must substitute the current time. Finally, each update <em>may</em> contain a <code>from</code> slot to identify the sending user. If the <code>from</code> slot is not given, the server automatically substitutes the known username for the connection the update is coming from.</p><p>When an update is sent to a channel, it is distributed to all the users currently in the channel. When an update is sent to a user, it is distributed to all the connections of the user. When an update is sent to a connection, it is serialised to the wire according to the above wire format specification. The actual underlying mechanism that transfers the characters of the wire format to the remote host is implementation-dependant.</p><h3 id="3.1 null termination of updates">3.1 Null Termination of Updates</h3><p>At the end of each update there has to be a single null character (<code>U+0000</code>). This character can be used to distinguish individual updates on the wire and may serve as a marker to attempt and stabilise the stream in case of malformed updates or other problems that might occur on the lower level.</p><h3 id="3.2 failures">3.2 Failures</h3><p>If an update cannot be performed for some reason, the server will respond with a <code>failure</code> update. If the client's update was successfully parsed, this failure must be a subclass of <code>update-failure</code>, which will reference the failed update's <code>id</code> in the <code>update-id</code> slot, so that the client can reconstruct which of the requests failed.</p><h3 id="3.3 warnings">3.3 Warnings</h3><p>In addition to the normal reply of an update – whether successful or failed – the server may also send an update that is a subclass of <code>warning</code>. This update <strong>must</strong> be <code>from</code> the primary user, and must reference the original update in its <code>update-id</code> slot. The client may use the warning to inform the user or adjust future behaviour in response to the server's notice.</p><p>Note that a warning may only be issued if the request is processed otherwise. The server <strong>must not</strong> only reply with a warning. The server further <strong>must</strong> reply with the warning <em>before</em> replying with the response to the original update.</p><h2 id="4. connection">4. Connection</h2><h3 id="4.1 connection establishment">4.1 Connection Establishment</h3><p>After the connection between a client and a server has been established through some implementation-dependant means, the client must send a <code>connect</code> update. The update will attempt to register the user on the server, as follows:</p><ol><li value="1"><p>If the server cannot sustain more connections, a <code>too-many-connections</code> update is returned and the connection is closed.</p></li><li value="2"><p>If the update's <code>version</code> denotes a version that is not compatible to the version of the protocol on the server, an <code>incompatible-version</code> update is returned and the connection is closed.</p></li><li value="3"><p>If the update's <code>from</code> field is missing or <code>NIL</code>, the server substitutes a <em>random</em> name that is not currently used by any other user or registered profile.</p></li><li value="4"><p>If the update's <code>from</code> field contains an invalid name, a <code>bad-name</code> update is returned and the connection is closed.</p></li><li value="5"><p>If the update does not contain a <code>password</code>, and the <code>from</code> field denotes a username that is already taken by an active user or a registered user, an <code>username-taken</code> update is returned and the connection is closed. </p></li><li value="6"><p>If the update does contain a <code>password</code>, and the <code>from</code> field denotes a username that is not registered, a <code>no-such-profile</code> update is returned and the connection is closed.</p></li><li value="7"><p>If the update does contain a <code>password</code>, and the <code>from</code> field denotes a username that is registered, but whose password does not match the given one, an <code>invalid-password</code> update is returned and the connection is closed.</p></li><li value="8"><p>If the server cannot sustain more connections for the requested user, a <code>too-many-connections</code> update is returned and the connection is closed.</p></li><li value="9"><p>A user corresponding in name to the <code>from</code> field is created if it does not yet exist.</p></li><li value="10"><p>The connection is tied to its corresponding user object.</p></li><li value="11"><p>The server responds with a <code>connect</code> update of the same id as the one the client sent. The <code>from</code> field must correspond to the user's actual name.</p></li><li value="12"><p>If the user already existed, the server responds with <code>join</code> updates for each of the channels the user is currently inhabiting, with the primary channel always being the first.</p></li><li value="13"><p>If the user did not already exist, it is joined to the primary channel.</p></li><li value="14"><p>The server sends a <code>message</code> update for the primary channel from the primary user. The message contents are up to the server, and should typically be some kind of welcome banner.</p></li></ol><p>Should the user send a <code>connect</code> update after already having completed the connection handshake above, the server must drop the update and respond with an <code>already-connected</code> update.</p><h3 id="4.2 connection maintenance">4.2 Connection Maintenance</h3><p>If the <code>clock</code> of an update diverges too much, the server may respond with a <code>clock-skewed</code> update and correct the timestamp. If the skew varies a lot, the server may drop the connection after replying with a <code>connection-unstable</code> update.</p><p>The server must receive an update on a connection within at least a certain implementation-dependant interval that must be larger than 100 seconds. If this does not happen, the server may assume a disconnection and drop the client after replying with a <code>connection-unstable</code> update. If the server does not receive an update from the client within an interval of up to 60 seconds, the server must send a <code>ping</code> update to the client, to which the client must respond with a <code>pong</code> update. This is to ensure the stability of the connection.</p><p>If the client sends too many updates in too short a time interval, the server may start dropping updates, as long as it responds with a <code>too-many-updates</code> update when it starts doing so. This throttling may be sustained for an implementation-dependant length of time. The client might send occasional <code>ping</code> requests to figure out if the throttling has been lifted. The server may also close the connection if it deems the flooding too severe.</p><p>Instead of a hard-throttle as described in the previous paragraph, the server may also implement a soft throttle by queueing updates and processing them after a delay. Should the client become throttled in this way, the server must send an <code>updates-throttled</code> warning once updates begin to be queued.</p><h3 id="4.3 connection closure">4.3 Connection Closure</h3><p>A connection may be closed either due to a <code>disconnect</code> update request from the client, or due to problems on the server side. When the connection is closed, the server must act as follows:</p><ol><li value="1"><p>The server responds with a <code>disconnect</code> update, if it still can.</p></li><li value="2"><p>The underlying connection between the client and the server is closed.</p></li><li value="3"><p>The connection object is removed from the associated user object.</p></li><li value="4"><p>If the user does not have any remaining connections, the user leaves all channels it inhabited.</p></li></ol><p>The exceptional situation being during connection establishment. If the server decides to close the connection then, it may do so without responding with a <code>disconnect</code> update and may immediately close the underlying connection.</p><h2 id="5. client interaction">5. Client Interaction</h2><h3 id="5.1 general update checks">5.1 General Update Checks</h3><p>An update is always checked as follows:</p><ol><li value="1"><p>If the update is not at all recognisable and cannot be parsed, a <code>malformed-update</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the update is too long (contains too many characters), a <code>update-too-long</code> update is sent back and the request is dropped.</p></li><li value="3"><p>If the class of the update is not known or not a subclass of <code>update</code>, an <code>invalid-update</code> update is sent back and the request is dropped.</p></li><li value="4"><p>If the <code>from</code>, <code>channel</code>, or <code> target</code> fields contain an invalid name, a <code>bad-name</code> update is sent back and the request is dropped.</p></li><li value="5"><p>If the <code>from</code> field does not match the name known to the server by the user associated to the connection, a <code>username-mismatch</code> update is sent back and the request is dropped.</p></li><li value="6"><p>If the <code>channel</code> field denotes a channel that does not exist, but must, a <code>no-such-channel</code> update is sent back and the request is dropped.</p></li><li value="7"><p>If the <code>target</code> field denotes a user that does not exist, a <code>no-such-user</code> update is sent back and the request is dropped.</p></li><li value="8"><p>If the update is an operation that is not permitted on its target channel, or the primary channel if no target channel is applicable, an <code>insufficient-permissions</code> update is sent back and the request is dropped.</p></li></ol><h3 id="5.2 profile registration">5.2 Profile Registration</h3><p>When a user sends a <code>register</code> update, the server must act as follows:</p><ol><li value="1"><p>If the server disagrees with the attempted registration, a <code>registration-rejected</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the profile does not yet exist, it is created.</p></li><li value="3"><p>The password of the profile associated to the user is changed to match the one from the update.</p></li><li value="4"><p>The profile must stay live until at least 30 days after the user associated with the profile has existed on the server.</p></li><li value="5"><p>The server responds by sending back the original <code>register</code> update.</p></li></ol><p>Note that the server does not need to store the password verbatim, and is instead advised to only store and compare a hash of it.</p><h3 id="5.3 channel creation &amp; management">5.3 Channel Creation &amp; Management</h3><p>Since a channel has only two bits of information associated with it, the management of channels is rather simple.</p><h4 id="5.3.1 creating a channel">5.3.1 Creating a Channel</h4><p>Creating a new channel happens with the <code>create</code> update:</p><ol><li value="1"><p>The update is checked for permissions by the primary channel.</p></li><li value="2"><p>If a channel of the <code>channel</code> name in the update already exists, the server responds with a <code>channelname-taken</code> update and drops the request.</p></li><li value="3"><p>If the user already inhabits the maximum amount of channels, the server responds with a <code>too-many-channels</code> update and drops the request.</p></li><li value="4"><p>If the <code>channel</code> field is <code>NIL</code>, an anonymous channel is created, otherwise a regular channel is created.</p></li><li value="5"><p>The user is automatically joined to the channel.</p></li><li value="6"><p>The server responds with a <code>join</code> update to the user with the <code>id</code> being the same as the id of the create update.</p></li></ol><h4 id="5.3.2 updating a channel">5.3.2 Updating a Channel</h4><p>The channel's permissions can be viewed or changed with the <code>permissions</code> update, if the channel allows you to do so.</p><ol><li value="1"><p>The permissions for the channel are updated with the ones specified in the update's <code>permissions</code> field as follows:<br>1. For each rule in the specified permissions set in the update:<br>2. If the rule should be malformed or unacceptable, the server responds with a <code>invalid-permissions</code> update and disregards the rule.<br>3. Otherwise, set the rule with the same type in the channel's rule set to the given rule.</p></li><li value="2"><p>The server responds with a <code>permissions</code> update with the <code>permissions</code> field set to the full permissions set of the channel, and the <code>id</code> being the same as the id of the update the user sent.</p></li></ol><p>See §2.5 for an explanation of the proper syntax of the permissions. Note that the server may reduce the set of rules to a simpler set that is semantically equivalent.</p><p>As a shortcut, permissions can also be managed with the <code>grant</code> and <code>deny</code> updates, which change an individual rule. When a server receives a <code>grant</code> update, it must update the corresponding rule as follows:</p><ol><li value="1"><p>If the rule is <code>T</code>, nothing is done.</p></li><li value="2"><p>If the rule is <code>NIL</code>, it is changed to <code>(+ user)</code>.</p></li><li value="3"><p>If the rule is an exclusion mask, <code>user</code> is removed from the mask.</p></li><li value="4"><p>If the rule is an inclusion mask, <code>user</code> is added to the mask if they are not already on it.</p></li></ol><p>When the server receives a <code>deny</code> update, it must update the corresponding rule as follows:</p><ol><li value="1"><p>If the rule is <code>T</code>, it is changed to <code>(- user)</code>.</p></li><li value="2"><p>If the rule is <code>NIL</code>, nothing is done.</p></li><li value="3"><p>If the rule is an exclusion mask, <code>user</code> is added to the mask if they are not already on it.</p></li><li value="4"><p>If the rule is an inclusion mask, <code>user</code> is removed from the mask.</p></li></ol><p>After processing either a <code>grant</code> or <code>deny</code> update successfully, the update is sent back to the user.</p><h3 id="5.4 channel interaction">5.4 Channel Interaction</h3><p>A user can interact with a channel in several ways. </p><h4 id="5.4.1 joining a channel">5.4.1 Joining a Channel</h4><p>Joining a channel happens with the <code>join</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is already in the named channel, an <code>already-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the user already inhabits the maximum amount of channels, the server responds with a <code>too-many-channels</code> update and drops the request.</p></li><li value="3"><p>The user is added to the channel's list of users.</p></li><li value="4"><p>The user's <code>join</code> update is distributed to all users in the channel.</p></li></ol><h4 id="5.4.2 leaving a channel">5.4.2 Leaving a Channel</h4><p>Leaving a channel again happens with the <code>leave</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>The user's <code>leave</code> update is distributed to all users in the channel.</p></li><li value="3"><p>The user is removed from the channel's list of users.</p></li></ol><h4 id="5.4.3 pulling a user">5.4.3 Pulling a User</h4><p>Another user can be pulled into the channel by the <code>pull</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the target user is already in the named channel, an <code>already-in-channel</code> update is sent back and the request is dropped.</p></li><li value="3"><p>If the target already inhabits the maximum amount of channels, the server responds with a <code>too-many-channels</code> update and drops the request.</p></li><li value="4"><p>The target user is added to the channel's list of users.</p></li><li value="5"><p>A <code>join</code> update for the target user with the same <code>id</code> as the <code>pull</code> update is distributed to all users in the channel.</p></li></ol><h4 id="5.4.4 kicking a user">5.4.4 Kicking a User</h4><p>Another user can be kicked from a channel by the <code>kick</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>If the target user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="3"><p>The user's <code>kick</code> update is distributed to all users in the channel.</p></li><li value="4"><p>A <code>leave</code> update for the target user is distributed to all users in the channel.</p></li><li value="5"><p>The target user is removed from the channel's list of users.</p></li></ol><h4 id="5.4.5 sending a message">5.4.5 Sending a Message</h4><p>Finally, a user can send a message to all other users in a channel with the <code>message</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>The user's <code>message</code> update is distributed to all users in the channel.</p></li></ol><h3 id="5.5 server information retrieval">5.5 Server Information Retrieval</h3><p>The server can provide a client with several pieces of information about its current state. </p><h4 id="5.5.1 listing public channels">5.5.1 Listing Public Channels</h4><p>Retrieving a list of channels can be done with the <code>channels</code> update, after which the server acts as follows:</p><ol><li value="1"><p>For each channel known to the server, the server checks the update against the channel's permissions.</p></li><li value="2"><p>If the permissions allow the update, the channel's name is recorded.</p></li><li value="3"><p>A <code>channels</code> update with the same <code>id</code> as the request is sent back with the <code>channels</code> field set to the list of names of channels that were recorded.</p></li></ol><h4 id="5.5.2 listing all users of a channel">5.5.2 Listing All Users of a Channel</h4><p>The list of users currently in a channel can be retrieved by the <code>users</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>A list of the users in the channel is recorded.</p></li><li value="3"><p>A <code>users</code> update with the same <code>id</code> as the request is sent back with the <code>users</code> field set to the list of names of users that were recorded.</p></li></ol><h4 id="5.5.3 requesting information about a user">5.5.3 Requesting Information About a User</h4><p>Information about a particular user can be retrieved by the <code>user-info</code> update, after which the server acts as follows:</p><ol><li value="1"><p>If the user is not connected and no profile for the user exists, a <code>no-such-user</code> update is sent back and the request is dropped.</p></li><li value="2"><p>A <code>user-info</code> update with the same <code>id</code> as the request is sent back with the <code>connections</code> field set to the number of connections the user object has associated with it and with the <code>registered</code> field set to <code>T</code> if the user has a profile associated with it.</p></li></ol><h4 id="5.5.4 requesting capabilities">5.5.4 Requesting Capabilities</h4><p>A user can request a list of updates they are allowed to send to a particular channel using the <code>capabilities</code> update. The server must act as follows:</p><ol><li value="1"><p>If the user is not in the named channel, a <code>not-in-channel</code> update is sent back and the request is dropped.</p></li><li value="2"><p>For every update type known to the server, the server checks whether the user is permitted according to the channel's permission rule for the update. If permitted, the update type is added to a list.</p></li><li value="3"><p>A <code>capabilities</code> update with the same <code>id</code> as the request is sent back with the <code>permitted</code> field set to the list of updates gathered in step 2.</p></li></ol><h4 id="5.5.5 requesting private information">5.5.5 Requesting Private Information</h4><p>Servers may store additional information about a user, such as statistics, IP addresses, and so forth. Such information can be requested through the <code>server-info</code> update. After receiving such an update, the server must act as follows:</p><ol><li value="1"><p>If the user is not connected and no profile for the user exists, a <code>no-such-user</code> update is sent back and the request is dropped.</p></li><li value="2"><p>A <code>server-info</code> update with the same <code>id</code> as the request is sent back with the <code>attributes</code> field set to an &quot;association list&quot;, and the <code>connections</code> field set to a list of &quot;association lists&quot;, one such &quot;association list&quot; per connection the user has. An association list is a list where each element has the following structure:</p><ul><li><p><code>(SYMBOL EXPR)</code>, where:</p></li><li><p><code>SYMBOL</code> is a symbol naming the attribute that is being returned.</p></li><li><p><code>EXPR</code> is the value for the attribute being returned.</p></li></ul></li></ol><p>The attributes being returned are dependent on the server and the supported protocol extensions. The set of returned attributes may also differ depending on the user being requested, especially if the user is the server's user.</p><p>The following attributes are specified:</p><ul><li><p><code>channels</code> A list of channel names in which the user resides.</p></li><li><p><code>registered-on</code> When the user registered their profile. <code>NIL</code> if they did not.</p></li></ul><p>The following connection attributes are specified:</p><ul><li><p><code>connected-on</code> The time at which the connection was initiated.</p></li></ul><p>While these attributes are specified in their purpose, a server does not have to return them.</p><h2 id="6. protocol extension">6. Protocol Extension</h2><p>A server or client may provide extensions to the protocol in the following manners:</p><ul><li><p><strong>Additional Update Types</strong><br>If such an update is sent to a client that does not recognise it, it should be ignored. If such an update is sent to a server that does not recognise it, the server will respond with an <code>invalid-update</code>.</p></li><li><p><strong>Additional Update Fields</strong><br>A client or server may extend the existing update classes with additional, optional fields to provide further information or other kinds of behaviour. The server or client is not allowed to introduce additional required fields. When an update with unknown initargs is received, the unknown initargs are to be ignored. An extension may only add existing, well-specified initargs in keyword form (<code>:text</code>, <code>:channel</code>, <code>:target</code>, <code>:update-id</code>). Other additional initargs must be symbols from an extension-owned package.</p></li><li><p><strong>Additional Constraints</strong><br>An extension may introduce additional constraints and restrictions on whether existing updates are considered valid.</p></li><li><p><strong>Additional User Attributes</strong><br>An extension may specify additional attributes stored in profiles and returned through <code>server-info</code>.</p></li></ul><p>Each extension to the protocol should receive a unique name of the form <code>producer-name</code> where <code>producer</code> is an identifier for who wrote up the extension's protocol, and <code>name</code> should be a name for the extension itself. For each extension that a server and client support, they must include the unique name of it as a string in the <code>connect</code> update's <code>extensions</code> list. Each producer also owns a symbol package with the producer's name, in which they may freely specify new symbols.</p><h3 id="6.1 known extensions">6.1 Known Extensions</h3><ul><li><p><a class="external-link" href="shirakumo.html">shirakumo.mess</a> Describes extensions from the Shirakumo collective.</p></li></ul><h2 id="7. general conventions">7. General Conventions</h2><p>The following are general conventions for server and client implementors. However, they are not mandatory to follow, as they may only make sense for certain types of implementations.</p><p>The default port when served over TCP should be <code>1111</code>, with <code>1112</code> being the default for SSL connections.</p><p>When specified in URLs, Lichat takes the <code>lichat</code> protocol and follows this general scheme: <code>lichat://host:port/channel#id</code> Meaning the URL path (if given) is used as the name for a channel to join. The URL fragment can be used to specify a specific message id. Note that it is the client's responsibility to ensure that the ID is sufficiently unique so that the URL will link to the correct message. The query part of the URL may be used for client-specific purposes.</p></article>